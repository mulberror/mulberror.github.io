---
title: "并查集 - 基础知识"
subtitle: ""
description: ""
slug: 9df9fb
date: 2024-11-13T15:12:10+08:00
lastmod: 2024-11-13T15:12:10+08:00
draft: false

resources:
# 文章特色图片
- name: featured-image
  src: featured-img.webp
# 首页预览特色图片
- name: featured-image-preview
  src: featured-img.webp

# 标签
tags: ['数据结构', '并查集', '图论']
# 分类
categories: ["算法"]
# 合集(如果下面这一行注释掉，就不会显示系列为空了)
# collections: [""]
# 从主页面中去除
hiddenFromHomePage: false
# 从搜索中去除
hiddenFromSearch: false

lightgallery: false

# 否开启表格排序
table:
  sort: false
toc:
  enable: true
  auto: true
expirationReminder:
  enable: false
  # ...
code:
  copy: true
  # ...
edit:
  enable: false
  # ...
math:
  enable: true
  # ...
mapbox:
  accessToken: ""
  # ...
share:
  enable: true
  # ...
comment:
  enable: true
  # ...
library:
  css:
    # someCSS = "some.css"
    # 位于 "assets/"
    # 或者
    # someCSS = "https://cdn.example.com/some.css"
  js:
    # someJS = "some.js"
    # 位于 "assets/"
    # 或者
    # someJS = "https://cdn.example.com/some.js"
seo:
  images: []
  # ...
---
## 前言

并查集是一个非常实用的数据结构，主要解决是判断两个元素是否在同一个集合中，也可以看成无向图连通性的检测问题，并且最基础的并查集也可以支持连接操作。

并查集本身的复杂度非常低，空间复杂度和时间复杂度基本可以看成线性的。

代码实现也非常简单，通过树的形式来表示集合，通过**路径压缩**和**按秩合并**来优化。

<!--more-->
## 问题描述

考虑一个基础的问题，假如说现在有 $n$ 个人，这 $n$ 个人中某些人具有血缘关系，问题就是查询某两个人是否有血缘关系。

例如，$A$ 和 $B$ 有血缘关系，$B$ 和 $C$ 有血缘关系，那么查询 $A$ 和 $C$ 时，两者就是有血缘关系的。这就是一个典型的并查集问题。

## 思路

以上问题既可以看成集合上的问题，也可以看成无向图上的问题，集合中的元素对应了图中的节点，集合中元素的关系对应了图上的边。以下从图论的角度对问题进行分析。

尝试将每个人看成一个节点，每个人之间的血缘关系看成是一条边，那么就可以将这个问题转化为一个图论中判断**无向图**连通性的问题。

> [!TIP]+ 连通性
> **连通性**是图论中的一个重要概念，在图论中有多种分类，如强弱连通性，涉及到的还有连通分量等概念。\
> 并查集解决的是无向图的连通性，也就是在无向图当中的两个点是否存在一条简单路径可以**相互到达**，所有可以相互到达的点构成一个连通块。

并查集算法的重要思路就是**将一个连通块简化为一个树，树的根节点就是这个连通块的代表，通过这个代表来判断两个节点是否在同一个连通块中。树上每一个节点都有一个指向其父节点的指针，根节点的指针指向自己。**

选择树的原因：

- 树是最小的无向连通图，树上所有的节点之间都存在**唯一**的简单路径可以相互到达。
- 树具有唯一的根节点，根节点可以代表整个连通块。
- 树上每一个节点的深度最浅的祖先都是根节点，可以通过不断寻找父节点来找到根节点。

对每一个节点 $x$，`fa[x]` 包含其父亲节点的编号。在没有边加入到图中的时候，每一个节点都是独立的连通块，即没有人和其他人有血缘关系，**其父亲节点就是它自己**。这就是并查集的初始状态。

```cpp
struct DSU {
    int n;                  // 节点个数
    std::vector<int> fa;    // 父亲节点

    DSU(int _n) : n(_n + 1) {
        fa.resize(n);
        std::iota(fa.begin(), fa.end(), 0); // 初始状态下，每一个节点的父亲节点就是它自己
    }
};
```

### 查询操作

根据并查集的主要思路，树的根节点代表了这个连通块，如果说两个节点所在的树的根节点相同，那么这两个节点就是在同一个连通块中；反之，则不在同一个连通块中。

```goat
    5         6      12
   / \       / \     |
  3   4     7   8    13
 / \       /   / \
1   2     9   10 11
```

以上图为例，$5$ 号节点代表了以 $5$ 号节点为树的连通块。其中 $2$ 号和 $4$ 号之间并没有边直接相连，但是根节点都是 $5$ 号节点，所以 $2$ 号和 $4$ 号在同一个连通块中。

同理，$1$ 号和 $11$ 号的根节点分别为 $5$ 号和 $6$ 号，所以 $1$ 号和 $11$ 号不在同一个连通块中。

那么在代码实现的时候，就需要一个函数来找到一个节点所在的连通块的根节点，这个函数就是 `find` 函数。该函数就是通过不断寻找父亲节点，直到找到根节点（根节点的父亲是自己）。

```cpp
int find(int x) {
    return x == fa[x] ? x : find(fa[x]); // 如果 x 的父亲节点是自己，那么 x 就是根节点
}
```

拥有了 `find` 函数，就可以很方便的判断两个节点是否在同一个连通块中。

```cpp
bool same(int x, int y) {
    return find(x) == find(y); // 如果两个节点的根节点相同，那么两个节点在同一个连通块中
}
```

### 合并操作

除了查询操作外，还需要加入加边操作，也就是集合的合并操作，这个操作就是将两个连通块合并为一个连通块。

首先如果两个节点已经在同一个连通块中，那么就不需要进行合并操作。如节点 $2$ 和节点 $4$ 在同一个连通块中，那么就不需要再次合并。

依旧以上图为例，将 $9$ 号、$12$ 号节点合并这个操作和将 $10$ 号、$13$ 节点合并这个操作结果相同，都是将以 $6$ 号节点为根的连通块和以 $12$ 号节点为根的连通块合并为一个连通块。

所以**合并的对象**也就被转换成了**连通块的根节点**，合并操作（加边操作）也就是将其中一个根节点的父亲节点指向另一个根节点。

```cpp
void merge(int x, int y) {
    int u = find(x), v = find(y);
    if (u != v) {
        fa[u] = v;
    }
}
```

比如说将上图的 $6$ 号节点和 $12$ 号节点合并，并将 $12$ 号节点的父亲节点指向 $6$ 号节点，合并后的图就如下图所示。

```goat
    5          6     
   / \       / | \    
  3   4     7  12 8   
 / \       /  /  / \
1   2     9  13 10 11
```

## 优化

以上的并查集是最基础的版本，但是在实际应用中，只这样操作会导致树的深度过深，从而导致查询操作的复杂度过高。

比如说合并的方式是 $1 \to 2 \to 3 \to 4$，那么查询 $1$ 和 $4$ 的根节点的时候，就需要不断的向上寻找父亲节点，直到找到根节点。

这样树就**退化成了一条链**，查询 $1$ 号节点的时候需要遍历 $O(n)$ 个节点，这样的复杂度是不可接受的。

针对以上的问题，一般的优化方法是**路径压缩**或**按秩合并**。

### 路径压缩

路径压缩是最常见的并查集优化方法，其思路是在查询的时候（递归返回的时候），将节点的父亲节点直接指向根节点，这样就可以减少树的深度。

也就是将一个树变成了一个菊花图。在经过一次查询后，查询的时间就从 $O(n)$ 降低到了 $O(1)$，总的时间复杂度是 $O(n\alpha(n))$，其中 $\alpha(n)$ 是 Ackermann 函数的反函数，增长非常缓慢，几乎可以看成是一个常数。

> [!TIP]- 证明路径压缩复杂度
> TODO：严格证明路径压缩的复杂度为 $O(\alpha n)$。

```cpp
struct DSU {
    int n;
    std::vector<int> fa;
    
    // ...
    int find(int x) {
        return x == fa[x] ? x : fa[x] = find(fa[x]);
    }

    // ...
};
```

不过这样的优化破坏了原本树的结构，这样的优化是并不可以应用于可持久化（查询历史信息）。

### 按秩合并

按秩合并是另一种优化方法，其思路是在合并的时候，将秩较小的树合并到秩较大的树上，这样可以平衡树的形状。

此处的秩即可以是树的深度，也可以是树中节点的个数（也称树的大小），此处以树的节点个数为例。这也可以叫做启发式合并。

```cpp
struct DSU {
    int n;
    std::vector<int> fa;
    std::vector<int> siz; // 树的大小

    DSU(int _n) : n(_n + 1) {
        fa.resize(n);
        siz.resize(n, 1);
        std::iota(fa.begin(), fa.end(), 0);
    }
    
    // ...
    int find(int x) {
        return x == fa[x] ? x : find(fa[x]);
    }

    void merge(int x, int y) {
        int u = find(x), v = find(y);
        if (u != v) {
            if (siz[u] < siz[v]) {
                std::swap(u, v);   // 保证 u 的大小大于 v
            }
            fa[v] = u;             // 将 v 的父亲节点指向 u
            siz[u] += siz[v];      // 更新树的大小
        }
    }

    // ...
};
```

> [!TIP]- 证明按秩合并复杂度
> TODO：严格证明按秩合并的复杂度为 $O(\log n)$。

按秩合并的时间复杂度是 $O(n\log n)$，时间复杂度并没有路径压缩的优化高，但是本身并没有破坏树的形状，所以可以应用于可持久化。
